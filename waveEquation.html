<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Modified Wave Equation</title>
    <style>
        body {
            margin: 0;
            background-color: black;
            color: white;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body onload="startup()">
    <div id="container"></div>
    <!-- Main THREE includes
    <script src="D:\Programas\felipunky.github.io\three.min.js"></script>-->
    <script src="felipunky.github.io/three.min.js"></script>
    <!-------------------->
    <!-- Shaders        -->
    <!-------------------->
    <!-- no change vertex shader. used for all render stages. -->
    <script id="VertShader" type="x-shader/x-vertex">
        void main()
        {

        gl_Position = vec4( position, 1.0 );

        }
    </script>

    <!-- BufferA. -->
    <script id="BufferAFrag" type="x-shader/x-fragment">
        // switch on high precision floats
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D iChannel0;
        uniform sampler2D iChannel1;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float iTimeDelta;
        uniform vec3 iMouse;

        mat2 rot( float a )
        {

        return mat2( cos( a ), -sin( a ),
        sin( a ),  cos( a )
        );

        }

        // This function returns the center of the uv coordinates and relates it to the mouse position
        float dis( vec2 uv, vec2 mou )
        {

        return 0.03 * cos( atan( uv.x - mou.x, uv.y - mou.y ) * 10.0 );

        }

        float hash( float a )
        {

        return fract( sin( a * 46354.93 ) * 37394.45 );

        }

        float cir( vec2 uv, vec2 mou )
        {

        float a = length( uv - mou );

        uv *= rot( iTime );
        mou *= rot( iTime );

        float dist = dis( uv, mou );

        float r = hash( iTime ) * 0.1 + dist;

        a = smoothstep( r, r - 0.0001, a );

        return a;

        }

        void main()
        {

        vec2 p = gl_FragCoord.xy / iResolution.y;
        vec2 uv = gl_FragCoord.xy / iResolution.xy;
        vec3 col = vec3( 0 );
        vec2 mou = iMouse.xy / iResolution.y;

        float c = cir( p, mou );

        // Thanks PatricioGonzalezVivo
        vec3 diff = vec3( vec2(1.0) / iResolution.xy, 0.0);

        vec4 center = texture2D(iChannel0, uv);
        float top = texture2D(iChannel0, uv - diff.zy).r;
        float left = texture2D(iChannel0, uv - diff.xz).r;
        float right = texture2D(iChannel0, uv + diff.xz).r;
        float bottom = texture2D(iChannel0, uv + diff.zy).r;

        vec3 red = vec3( -(center.a - 0.5) * 2.0 + (top + left + right + bottom - 2.0) );

        /*if( iMouse.z < 0.5 )
        {

        c = cir( p, vec2( 0.9 + sin( iTime * 5.0 ) * 0.5, 0.5 - cos( iTime * 5.0 ) * 0.5 ) );

        }*/

        vec3 ran = vec3( c * hash( iTimeDelta + 5.0 ), c * hash( iTimeDelta + 2.0 ), c * hash( iTimeDelta + 1.0 ) );

        red += c; // mouse
        red *= 0.98; // damping
        red *= step(0.1, iTime); // hacky way of clearing the buffer
        red = 0.5 + red * 0.5;
        red = clamp(red, 0., 1.);

        gl_FragColor = vec4(red, center.r);
        gl_FragColor += 0.05 * texture2D( iChannel0, uv );
        gl_FragColor *= vec4( 1.0, 1.5, 1.3, 1.0 );

        }
    </script>

    <!-- BufferB. -->
    <script id="BufferBFrag" type="x-shader/x-fragment">

        // switch on high precision floats
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D iChannel0;
        uniform sampler2D iChannel1;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float iTimeDelta;
        uniform vec3 iMouse;

        void main (void)
        {
        vec4 col = texture2D(fb2output, texCoord);
        gl_FragColor = col;
        }
    </script>
    <!-- BufferC. -->
    <script id="BufferCFrag" type="x-shader/x-fragment">

        // switch on high precision floats
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D iChannel0;
        uniform sampler2D iChannel1;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float iTimeDelta;
        uniform vec3 iMouse;

        void main (void)
        {
        vec4 col = texture2D(fb2output, texCoord);
        gl_FragColor = col;
        }
    </script>
    <!-- Image. -->
    <script id="ImageFrag" type="x-shader/x-fragment">

        // switch on high precision floats
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D iChannel0;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float iTimeDelta;
        uniform vec3 iMouse;

        void main()
        {

        vec2 uv = gl_FragCoord.xy / iResolution.xy;

        vec4 col = texture2D( iChannel0, uv );

        gl_FragColor = col;

        }
    </script>

    <!-------------------->
    <!-- Main Logic     -->
    <!-------------------->
    <script>
        //------------------------------------------
        // Globals
        //------------------------------------------
        var cameraLoop, camera, BufferAScene, BufferAFeedBackScene, BufferBScene, BufferCScene, BufferImageScene, renderer;
        var BufferA, BufferAFeedBack, BufferB, BufferC, Image;
        var BufferAUniforms, BufferBUniforms, BufferCUniforms, ImageUniforms;
        var BufferAQuad, BufferBQuad, BufferAFeedBackQuad, BufferCQuad, ImageQuad;
        var BufferAMat, BufferBMat, BufferCMat, ImageMat;
        var timeDelta = 0.0;
        //var loopRes = new THREE.Vector2(64.0, 64.0);
        var even = true;
        //var outputRes = new THREE.Vector2(512.0, 512.0);

        //var doLoad = 0.0;
        //          var onOpen = 0.0;

        var renderTargetNearestFloatParams = {
            minFilter: THREE.LinearFilder,
            magFilter: THREE.NearestFilter,
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            format: THREE.RGBAFormat,
            stencilBuffer: false,
            depthBuffer: false,
            needsUpdate: true,
            type: THREE.FloatType
        };

        //------------------------------------------
        // Main init and loop
        //------------------------------------------
        start();
        update();

        //------------------------------------------
        // Initialization
        //------------------------------------------
        function start() {

            container = document.getElementById('container');

            //setup scenes
            BufferAScene = new THREE.Scene();
            BufferAFeedBackScene = new THREE.Scene();
            BufferBScene = new THREE.Scene();
            BufferCScene = new THREE.Scene();
            BufferImageScene = new THREE.Scene();

            //setup renderer
            renderer = new THREE.WebGLRenderer();
            scale = window.devicePixelRatio;
            renderer.setPixelRatio(scale);
            container.appendChild(renderer.domElement);

            // create buffers
            BufferA = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetNearestFloatParams);
            BufferAFeedBack = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetNearestFloatParams);
            BufferB = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetNearestFloatParams);
            BufferC = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetNearestFloatParams);
            BufferImage = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetNearestFloatParams);

            // Setup algorithm camera
            //cameraLoop = new THREE.OrthographicCamera( loopRes.x / - 2, loopRes.x / 2, loopRes.y / 2, loopRes.y / - 2, -10000, 10000 );

            // Setup output camera
            camera = new THREE.Camera();
            camera.position.z = 1;

            // BufferA.
            BufferAUniforms = {
                iChannel0: { value: BufferA },
                iChannel1: { value: BufferB },
                iTime: { value: 1.0 },
                iResolution: { value: new THREE.Vector2() },
                iMouse: { value: new THREE.Vector3() },
                iTimeDelta: { value: timeDelta }
            };
            BufferAMat = new THREE.ShaderMaterial({
                uniforms: BufferAUniforms,
                vertexShader: document.getElementById('VertShader').textContent,
                fragmentShader: document.getElementById('BufferAFrag').textContent
            });
            var BufferAGeo = new THREE.PlaneBufferGeometry(2, 2);
            BufferAQuad = new THREE.Mesh(BufferAGeo, BufferAMat);
            BufferAScene.add(BufferAQuad);

            // BufferAFeedBack.
            BufferAFeedBackQuad = new THREE.Mesh(BufferAGeo, BufferAMat);
            BufferAFeedBackScene.add(BufferAFeedBackQuad);

            // BufferB.
            BufferBUniforms = {
                iChannel0: { value: BufferB },
                iChannel1: { value: BufferC },
                iTime: { value: 1.0 },
                iResolution: { value: new THREE.Vector2() },
                iMouse: { value: new THREE.Vector3() },
                iTimeDelta: { value: timeDelta }
            };
            BufferBMat = new THREE.ShaderMaterial({
                uniforms: BufferBUniforms,
                vertexShader: document.getElementById('VertShader').textContent,
                fragmentShader: document.getElementById('BufferBFrag').textContent,
            });
            var BufferBGeo = new THREE.PlaneBufferGeometry(2, 2);
            BufferBQuad = new THREE.Mesh(BufferBGeo, BufferBMat);
            BufferBScene.add(BufferBQuad);

            // BufferC.
            BufferCUniforms = {
                iChannel0: { value: BufferC },
                iTime: { value: 1.0 },
                iResolution: { value: new THREE.Vector2() },
                iMouse: { value: new THREE.Vector3() },
                iTimeDelta: { value: timeDelta }
            };
            BufferCMat = new THREE.ShaderMaterial({
                uniforms: BufferCUniforms,
                vertexShader: document.getElementById('VertShader').textContent,
                fragmentShader: document.getElementById('BufferBFrag').textContent,
            });
            var BufferCGeo = new THREE.PlaneBufferGeometry(2, 2);
            BufferCQuad = new THREE.Mesh(BufferCGeo, BufferCMat);
            BufferCScene.add(BufferCQuad);

            // Image Loader.
            /*const loader = new THREE.TextureLoader();
            const url = 'https://s3.amazonaws.com/duhaime/blog/tsne-webgl/assets/cat.jpg';
            const texture = loader.load(url);
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;*/

            // Image.
            ImageUniforms = {
                //iChannel0: { type: "t", value: BufferA },
                iChannel0: { value: BufferA },
                iTime: { value: 0.0 },
                iResolution: { value: new THREE.Vector2() },
                iMouse: { value: new THREE.Vector3() },
                iTimeDelta: { value: timeDelta }
            };
            ImageMat = new THREE.ShaderMaterial({
                uniforms: ImageUniforms,
                vertexShader: document.getElementById('VertShader').textContent,
                fragmentShader: document.getElementById('ImageFrag').textContent
            });
            var ImageGeo = new THREE.PlaneBufferGeometry(2, 2);
            ImageQuad = new THREE.Mesh(ImageGeo, ImageMat);
            BufferImageScene.add(ImageQuad);

            onWindowResize();
            window.addEventListener('resize', onWindowResize, false);

            var x = 0, y = 0;

            document.getElementById("container").onmousemove = function (e) {

                if (BufferAUniforms.iMouse.value.z === 1) {

                    x = e.pageX;
                    y = window.innerHeight - e.pageY;

                    BufferAUniforms.iMouse.value.x = x;
                    BufferAUniforms.iMouse.value.y = y;

                }

            }

            document.getElementById("container").onmousedown = function (e) {

                BufferAUniforms.iMouse.value.z = 1;

            }

            document.getElementById("container").onmouseup = function (e) {

                BufferAUniforms.iMouse.value.z = 0;

            }

        }

        //------------------------------------------
        // Main loop
        //------------------------------------------
        function update() {
            requestAnimationFrame(update);
            timeDelta += update;
            render();
        }

        //------------------------------------------
        // Main rendering
        //------------------------------------------
        function render() {


            renderer.setRenderTarget(BufferA);
            renderer.render(BufferAScene, camera);
            ImageUniforms.iChannel0.value = BufferA;
            renderer.setRenderTarget(null);

            renderer.setRenderTarget(BufferAFeedBack);
            renderer.render(BufferAFeedBackScene, camera);

            var feedBack = BufferAFeedBack;
            BufferAFeedBack = BufferA;
            BufferA = feedBack;

            BufferAUniforms.iChannel0.value = BufferAFeedBack;
            renderer.setRenderTarget(null);

            //renderer.setRenderTarget(BufferImage);
            ImageUniforms.iTime.value += 0.05;
            renderer.render(BufferImageScene, camera);
            //renderer.setRenderTarget(null);

            even = !even;

        }

        function startup() {

            var el = document.getElementById("container");
            el.addEventListener("touchstart", handleStart, false);
            el.addEventListener("touchend", handleEnd, false);
            el.addEventListener("touchcancel", handleCancel, false);
            el.addEventListener("touchmove", handleMove, false);

        }

        function handleStart(evt) {

            evt.preventDefault();
            var el = document.getElementById("container");
            BufferAUniforms.iMouse.value.z = 1;

        }

        function handleMove(evt) {

            evt.preventDefault();
            var el = document.getElementById("container");
            var touches = evt.changedTouches;
            var x = 0, y = 0;

            if (BufferAUniforms.iMouse.value.z === 1) {

                x = touches[0].pageX;
                y = window.innerHeight - touches[0].pageY;

                BufferAUniforms.iMouse.value.x = x;
                BufferAUniforms.iMouse.value.y = y;

            }

        }

        function handleEnd(evt) {

            evt.preventDefault();
            ImageUniforms.iMouse.value.z = 0;

        }

        function handleCancel(evt) {

            evt.preventDefault();
            ImageUniforms.iMouse.value.z = 0;

        }

        function onWindowResize(event) {

            renderer.setSize(window.innerWidth, window.innerHeight);
            BufferAUniforms.iResolution.value.x = renderer.domElement.width;
            BufferAUniforms.iResolution.value.y = renderer.domElement.height;
            ImageUniforms.iResolution.value.x = renderer.domElement.width;
            ImageUniforms.iResolution.value.y = renderer.domElement.height;

        }

    </script>
</body>
</html>  