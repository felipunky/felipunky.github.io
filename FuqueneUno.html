<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Modified Wave Equation</title>
    <style>
        body {
            margin: 0;
            background-color: black;
            color: white;
        }

        canvas {
            width: 100%;
            height: 100%
        }

        #container {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body onload="startup()">
    <div id="container"></div>
    <!-- Main THREE includes-->
    <!--<script src="https://ajax.googleapis.com/ajax/libs/threejs/r84/three.min.js"></script>-->
    <!--<script src="D:\Programas\felipunky.github.io\three.min.js"></script>-->
    <!--<script src="felipunky.github.io/three.min.js"></script>-->
    <script src="/Users/Felipe/Documents/GitHub/felipunky.github.io/three.min.js"></script>
    <!--<script src="C:\Users\Paula\Desktop\Felipe\felipunky.github.io\three.min.js"></script>-->
    <!--<script src="D:\SSS\three.js\build\three.min.js"></script>-->
    <!-------------------->
    <!-- Shaders        -->
    <!-------------------->
    <!-- no change vertex shader. used for all render stages. -->
    <script id="VertShader" type="x-shader/x-vertex">
        void main()
        {
        gl_Position = vec4( position, 1.0 );
        }
    </script>

    <!-- BufferA. -->
    <script id="BufferAFrag" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif
        #extension GL_OES_standard_derivatives : enable
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float iTimeDelta;
        uniform vec3 iMouse;
        
        vec2 mou = iMouse.xy / iResolution.y;
        vec3 colO = vec3( 0 );
        float d = 0.0, tim = iTime * 0.15;
        const float eps = 1e-2, freq = 2.2, ampl = 0.3, hei = 0.5;
        
        float hash( vec2 uv )
        {
            
            return fract( 2893.93 * sin( uv.x * 6382.43 + uv.y * 9283.223 ) );
            
        }
    
        float noise( vec2 uv )
        {
            
            vec2 lv = fract( uv );
            lv *= lv * ( 3.0 - 2.0 * lv );
            vec2 id = floor( uv );
            
            vec2 top = vec2( hash( id + vec2( 0, 1 ) ), hash( id + vec2( 1 )    ) );
            vec2 bot = vec2( hash( id ),                hash( id + vec2( 1, 0 ) ) );
            
            float dY = mix( top.x, top.y, lv.x );
            float dX = mix( bot.x, bot.y, lv.x );
            
            return mix( dX, dY, lv.y );
            
        }
    
        float fbm( vec2 uv )
        {
            
            float amp = 1.0, fre = 1.0, tot = 0.0, div = 0.0;
            
            for( int i = 0; i < 4; ++i )
            {
                
                tot += amp * noise( uv * fre );
                amp *= ampl;
                fre *= freq;
                //div += 1.0;
                
            }
            
            return tot * hei;// / div;
            
        }
    
        float fbmO( vec2 uv )
        {
            
            float amp = 1.0, fre = 1.0, tot = 0.0, div = 0.0;
            
            for( int i = 0; i < 2; ++i )
            {
                
                tot += amp * noise( uv * fre );
                amp *= ampl;
                fre *= freq;
                //div += 1.0;
                
            }
            
            return tot * hei;// / div;
            
        }
    
        float fbmT( vec2 uv )
        {
            
            float amp = 1.0, fre = 1.0, tot = 0.0, div = 0.0;
            
            for( int i = 0; i < 3; ++i )
            {
                
                tot += amp * noise( uv * fre );
                div += amp;
                amp *= 0.7;
                fre *= 2.0;
                
            }
            
            return tot / div;
            
        }
        
        float cir( vec2 uv, float r, float b )
        {
            
            return smoothstep( r, r - b, length( uv - mou ) );
            
        }
        
        mat2 rot( float a )
        {
            
            return mat2( cos( a ), -sin( a ),
                         sin( a ),  cos( a )
                        );
        
        }
    
        float map( vec3 p )
        {
            
            return p.y + fbm( p.xz );
            
        }
    
        float mapO( vec3 p )
        {
            
            return p.y + fbmO( p.xz );
            
        }
    
        vec3 gra( vec3 p )
        {
            
            vec2 e = vec2( eps, 0 );
            
            return normalize( vec3( map( p + e.xyy ) - map( p - e.xyy ),
                                    map( p + e.yxy ) - map( p - e.yxy ),
                                    map( p + e.yyx ) - map( p - e.yyx )
                                   )
                             );
            
        }
    
        float ray( vec3 ro, vec3 rd )
        {
            
            float t = 0.0;
            
            for( int i = 0; i < 64; ++i )
            {
                
                d = map( ro + rd * t );
                
                if( abs( d ) < eps || t > 6.0 ) break;
                
                t += d;
                colO.gb += 0.004;
                
            }
            
            return t;
            
        }
    
        vec3 pla( float t )
        {
            
            return mix(
                       vec3( 0.0, 0.1, 0.15 ),
                       vec3( 0.0, 0.4, 0.5 ),
                       t
                       );
                       
        }
    
        vec3 sha( vec3 ro, vec3 rd )
        {
            
            float t = ray( ro, rd );
            vec3 p = ro + rd * t, col = vec3( 0 ), n = gra( p ), lig = vec3( 0, 0.5, -5.0 - tim );
            lig = normalize( lig );
            
            float amb = 0.5 + 0.5 * n.y;
            float dif = max( 0.0, dot( n, lig ) );
            col += 0.2 * amb;
            col += pla( 0.5 ) * dif;
            col += colO;
            
           //col /= 0.6 * t;
            
            return col;
            
        }
    
        void main()
        {
            
            vec2 uv = ( -iResolution.xy + 2.0 * gl_FragCoord.xy ) / iResolution.y;
            
            //float tim = iTime * 0.5;
            
            vec3 ro = vec3( 0, 0, 2 );
            ro.z += tim;
            vec3 rd = normalize( vec3( uv, 1 ) );
            ro.y += 1.4 - mapO( ro );
            float t = ray( ro, rd );
            vec3 p = ro + rd * t;
            
            //rd.y += mapO( rd );
            
            vec3 col = vec3( 0 ), back = vec3( 0 );
            
            //if( length( uv ) < 0.5 )
            
            float l = length( uv ), s = smoothstep( 0.507, 0.487, l ), ti = iTime * 0.05;
            vec2 uvM = uv * 5.0;
            back = mix(
                        mix( back, vec3( 0, 0.3, 1 ), s ),
                        pla( fbmT( vec2( ti, 0 ) + uvM + fbmT( vec2( 0, ti ) + uvM ) ) ),
                        smoothstep(
                                   0.5,
                                   0.49,
                                   l
                                  )
                       );
              
            float shadow = smoothstep( 0.1, 0.9, length( uv + vec2( 0.4, 0 ) ) );
              
            back = mix( vec3( 0 ), back, shadow );
            
            d < eps ? col = sha( ro, rd ) : col = back;
            
            //col = pow( col, vec3( 0.4545 ) );
            
            gl_FragColor = vec4( col, 1 );
        
        }
    </script>

    <!-- Image. -->
    <script id="ImageFrag" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif
        #extension GL_OES_standard_derivatives : enable
        uniform sampler2D iChannel0;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float iTimeDelta;
        uniform vec3 iMouse;
        
        float normpdf(in float x, in float sigma)
        {
            return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;
        }
        
        void main()
        {
        
            //declare stuff
            const int mSize = 11;
            const int kSize = (mSize-1)/2;
            float kernel[mSize];
            vec3 final_colour = vec3(0.0);
            
            //create the 1-D kernel
            float sigma = 12.0;
            float Z = 0.0;
            
            vec2 uv = gl_FragCoord.xy / iResolution.xy, mou = iMouse.z < 0.5 ? vec2( 0.5 ) : iMouse.xy / iResolution.y, p = gl_FragCoord.xy / iResolution.y;
            
            if( length( p - mou ) > 0.35 )
            {
            
                for (int j = 0; j <= kSize; ++j)
                {
                    kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);
                }
                
                //get the normalization factor (as the gaussian has been clamped)
                for (int j = 0; j < mSize; ++j)
                {
                    Z += kernel[j];
                }
                
                //read out the texels
                for (int i=-kSize; i <= kSize; ++i)
                {
                    for (int j=-kSize; j <= kSize; ++j)
                    {
                        final_colour += kernel[kSize+j]*kernel[kSize+i]*texture2D(iChannel0, (gl_FragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;
                        
                    }
                }
                
                
                gl_FragColor = vec4(final_colour/(Z*Z), 1.0);
            
            }
            
            else
            {
                
                gl_FragColor = texture2D( iChannel0, uv );
                
            }
            
        }
    
    </script>

    <!-------------------->
    <!-- Main Logic     -->
    <!-------------------->
    <script>
        //------------------------------------------
        // Globals
        //------------------------------------------
        var camera, BufferAScene, BufferAFeedBackScene, BufferImageScene, renderer;
        var BufferA, BufferAFeedBack;
        var BufferAUniforms, ImageUniforms;
        var BufferAQuad, BufferAFeedBackQuad, ImageQuad;
        var BufferAMat, ImageMat;
        var clock = new THREE.Clock();
        var timeDelta = 0.0;
        var width = 0.0, height = 0.0, scaleRatio = 0.0;
        var renderTargetNearestFloatParams = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            format: THREE.RGBAFormat,
            stencilBuffer: false,
            depthBuffer: false,
            needsUpdate: true,
            type: THREE.FloatType
        };
        //------------------------------------------
        // Main init and loop
        //------------------------------------------
        start();
        update();
        //------------------------------------------
        // Initialization
        //------------------------------------------
        function start() {
            container = document.getElementById('container');
            //setup scenes
            BufferAScene = new THREE.Scene();
            BufferAFeedBackScene = new THREE.Scene();
            BufferImageScene = new THREE.Scene();
            //setup renderer
            renderer = new THREE.WebGLRenderer();
            scale = window.devicePixelRatio;
            renderer.setPixelRatio(scale);
            container.appendChild(renderer.domElement);
            scaleRatio = window.innerWidth / window.innerHeight;
            width = 470;
            height = 470;
            
            container.width = width;
            container.height = height;
            // create buffers
            BufferA = new THREE.WebGLRenderTarget(width, height, renderTargetNearestFloatParams);
            //BufferAFeedBack = new THREE.WebGLRenderTarget(width, height, renderTargetNearestFloatParams);
            // Setup output camera
            camera = new THREE.Camera();
            camera.position.z = 1;
            // BufferA.
            BufferAUniforms = {
                //iChannel0: { value: BufferA },
                iTime: { value: 1.0 },
                iResolution: { value: new THREE.Vector2(width, height) },
                iMouse: { value: new THREE.Vector3() },
                iTimeDelta: { value: timeDelta }
            };
            BufferAMat = new THREE.ShaderMaterial({
                uniforms: BufferAUniforms,
                vertexShader: document.getElementById('VertShader').textContent,
                fragmentShader: document.getElementById('BufferAFrag').textContent
            });
            var BufferAGeo = new THREE.PlaneBufferGeometry(2, 2);
            BufferAQuad = new THREE.Mesh(BufferAGeo, BufferAMat);
            BufferAScene.add(BufferAQuad);
            // BufferAFeedBack.
            /*BufferAFeedBackQuad = new THREE.Mesh(BufferAGeo, BufferAMat);
            BufferAFeedBackScene.add(BufferAFeedBackQuad);*/
            // Image.
            ImageUniforms = {
                iChannel0: { value: BufferA },
                iTime: { value: 0.0 },
                iResolution: { value: new THREE.Vector2(width * scale, height * scale) },
                iMouse: { value: new THREE.Vector3() },
                iTimeDelta: { value: timeDelta }
            };
            ImageMat = new THREE.ShaderMaterial({
                uniforms: ImageUniforms,
                vertexShader: document.getElementById('VertShader').textContent,
                fragmentShader: document.getElementById('ImageFrag').textContent
            });
            var ImageGeo = new THREE.PlaneBufferGeometry(2, 2);
            ImageQuad = new THREE.Mesh(ImageGeo, ImageMat);
            BufferImageScene.add(ImageQuad);
            onWindowResize();
            window.addEventListener('resize', onWindowResize, false);
            var x = 0, y = 0;
            document.getElementById("container").onmousemove = function (e) {
                if (BufferAUniforms.iMouse.value.z === 1) {
                    var element = document.getElementById("container").getBoundingClientRect();
                    x = (e.offsetX);//e.pageX;
                    y = (element.height - e.offsetY);//window.innerHeight - e.pageY;
                    BufferAUniforms.iMouse.value.x = x;
                    BufferAUniforms.iMouse.value.y = y;
                    ImageUniforms.iMouse.value.x = (x) * scale;
                    ImageUniforms.iMouse.value.y = (y) * scale;
                }
            }
            document.getElementById("container").onmousedown = function (e) {
                BufferAUniforms.iMouse.value.z = 1;
                ImageUniforms.iMouse.value.z = 1;
            }
            document.getElementById("container").onmouseup = function (e) {
                BufferAUniforms.iMouse.value.z = 0;
                ImageUniforms.iMouse.value.z = 0;
            }
        }
        //------------------------------------------
        // Main loop
        //------------------------------------------
        function update() {
            requestAnimationFrame(update);
            BufferAUniforms.iTime.value += 0.05;
            ImageUniforms.iTime.value += 0.05;
            render();
        }
        //------------------------------------------
        // Main rendering
        //------------------------------------------
        function render() {
            renderer.setSize(width, height);
            BufferAUniforms.iTimeDelta.value = timeDelta;
            //BufferAUniforms.iChannel0.value = BufferAFeedBack.texture;
            ImageUniforms.iChannel0.value = BufferA.texture;
            renderer.setRenderTarget(BufferA);
            renderer.render(BufferAScene, camera);
            renderer.setRenderTarget(null);
            renderer.clear();
            //let temp = BufferA;
            //BufferA = BufferAFeedBack;
            //BufferAFeedBack = temp;
            timeDelta = clock.getDelta();
            renderer.render(BufferImageScene, camera);
        }
        function startup() {
            var el = document.getElementById("container");
            el.addEventListener("touchstart", handleStart, false);
            el.addEventListener("touchend", handleEnd, false);
            el.addEventListener("touchcancel", handleCancel, false);
            el.addEventListener("touchmove", handleMove, false);
        }
        function handleStart(evt) {
            evt.preventDefault();
            var el = document.getElementById("container");
            BufferAUniforms.iMouse.value.z = 1;
            ImageUniforms.iMouse.value.z = 1;
        }
        function handleMove(evt) {
            evt.preventDefault();
            //var el = document.getElementById("container");
            //var rect = el.getBoundingClientRect();
            var touches = evt.targetTouches;
            var x = 0, y = 0;
            if (BufferAUniforms.iMouse.value.z === 1) {
                /*
                x = (e.offsetX) * scale;//e.pageX;
                y = (element.height - e.offsetY) * scale;//window.innerHeight - e.pageY;
                x = touches[0].pageX * scale;
                y = (window.innerHeight - touches[0].pageY) * scale;
                */
                var element = document.getElementById("container").getBoundingClientRect();
                var bodyRect = document.body.getBoundingClientRect();
                //x = evt.changedTouches[0].clientX - element.left;
                //y = element.height * 2.0 + scale - evt.changedTouches[0].clientY;
                var h = (element.top - bodyRect.top);
                var w = (element.left - bodyRect.left);
                x = touches[0].pageX - w;
                y = touches[0].pageY - h;
                BufferAUniforms.iMouse.value.x = (x);
                BufferAUniforms.iMouse.value.y = height - (y);
                ImageUniforms.iMouse.value.x = (x) * scale;
                ImageUniforms.iMouse.value.y = (y) * scale;
            }
        }
        function handleEnd(evt) {
            evt.preventDefault();
            BufferAUniforms.iMouse.value.z = 0;
            ImageUniforms.iMouse.value.z = 0;
        }
        function handleCancel(evt) {
            evt.preventDefault();
            BufferAUniforms.iMouse.value.z = 0;
            ImageUniforms.iMouse.value.z = 0;
        }
        function onWindowResize(event) {
            renderer.setSize(width * scale, height * scale);
            //BufferAUniforms.iResolution.value.x = renderer.domElement.width;
            //BufferAUniforms.iResolution.value.y = renderer.domElement.height;
            //ImageUniforms.iResolution.value.x = renderer.domElement.width;
            //ImageUniforms.iResolution.value.y = renderer.domElement.height;
            //BufferA.setSize(renderer.domElement.width, renderer.domElement.height);
            //BufferAFeedBack.setSize(renderer.domElement.width, renderer.domElement.height);
        }
    </script>
</body>
</html>

